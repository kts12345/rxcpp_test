## 01_01.cpp
#### Rx 컨셉 및 규칙 
----------------
##### observer [컨셉] 
* rx 규칙을 준수하는 이벤트 수신 객체
* 맴버 함수 : on_next, on_complete, on_error 
* app 에서 observer 오브젝트를 직접 만들지 않고, rx 툴킷이 (자동으로) 만들어 줌.  
  app 에서는 아래 함수를 제공  
  * on_next 가 호출할 함수,  
  * on_error 가 호출할 함수,  
  * on_complete가 호출할 함수
  ```cpp
  13: auto handler_next      = [](evt_t i) { console::log  ("on_next: "s  + i); };
  14: auto handler_error     = [](auto  e) { console::error("on_error: "s + e); };
  15: auto handler_completed = []          { console::info ("on_completed");    };
  ```

##### observable [컨셉] : 
* rx 규칙에 따라 이벤트를 발생시키는 객체
* rx::observable<>::create<evt_t>(...) 함수로 생성
  * 이벤트 타입을 템플릿 패러미터로 명시해 줌. (::create<evt_t>)
  ```cpp
  22: auto observable   = rx::observable<>::create<evt_t>(when_subscribe)
  ```
  
* subscribe 맴버 함수
  * 이벤트 수신 오브젝트 observer 를  
     이벤트 송신 오브젝트 observable 에 등록.
  * 구독을 의미하는 subscription 을 리턴.
  ```cpp
  23: auto subscription = observable.subscribe(handler_next,
  24:                                          handler_error,
  25:                                          handler_completed);
  ```


##### OnSubscribe[컨셉] :
* rx.observable.create() 함수의 콜백 형태 인자 (예제에서는 when_subscribe)
* observer 가 이벤트를 수신하겠다고 등록되는 시점에,  
  즉, observable.subscrib() 함수 내부에서 sync 호출됨
  * 예제에서는 이벤트 [11,12] 생성 후 종료하게 작성됨
  ```cpp
  12: auto when_subscribe = [](auto& observer) {
  13:   observer.on_next(evt_t(11));
  14:   observer.on_next(evt_t(12));
  15:   observer.on_completed();
  16:  };
  ```


####

  
#### Rx 내부 구현
----------------
* 아래와 같이 코드 변경 후 출력 값 확인해 보기 (14 라인과 15라인을 바꿨음)
```cpp
12: auto when_subscribe = [](auto& observer) {
13:   observer.on_next(evt_t(11));
14:   observer.on_completed();
15:   observer.on_next(evt_t(12));
16: };
```

* handler_next 에 braek_point를 잡고 callstack 을 살펴보기
```cpp
18: auto handler_next = [](evt_t i) { console::log  ("on_next: "s  + i); };
```
  * [기본] app 레벨의 함수 콜 graph 를 그려 보기.
  * [심화] try/catch 예외 상황 처리 쪽도 살펴 보기.
* handler_complete 에 break_point를 잡고 callstack 을 살펴보기
```cpp
20: auto handler_completed = []{ console::info ("on_completed"); };
```
  * [기본] app 레벨의 함수 콜 graph 를 그려 보기.
  * [심화] 앞서 테스트 했던 on_complete 후에 on_next가 호출되지 않는 케이스   
    에 대한 구현 부분 살펴보기. 

#### Modern C++
----------------
* javascript 의 ``string + int == string``  구현
  기본적으로 c/c++ 에서는 "hello " + 3 == "lo "  임
   ```cpp
     // int i = 11
   18: ... console::log("on_next: "s  + i);
     // 콘솔창 출력>on_next: 11
   ```
  * 단계1. const char * 를 string으로 변환하기
  ```cpp
    using namespace std::literals::string_literals;
    "hello"s // == std::string("hello")
   ```
  * 단계2. operator+(std::string, T) 정의하기
  ```cpp
    // node_util/string_conversion.hpp 참조
    template<typename T>
    std::string operator+ (const std::string& str, const T& t) {
      using namespace std;
      return str + to_string(t);
    }
  ```
* lambda 정의 문법
  * 매개변수가 없는 경우 괄호 생략 가능  
    따라서  []{}() 는 람다를 정의하자 마자 호출하는 valid 한 c++ 문법임
  ```cpp
    20: auto handler_completed = []{ console::info ("on_completed"); };
  ```

* [심화] std::exception_ptr
  * 아래 on_error 의 패러미터 타입은 std::exception_ptr 임.
  ```cpp
   19: auto handler_error = [](auto e) { console::error("on_error: "s + e); };
  ```
  * exception 관련 상세 내용은 다른 자료 참조 [ToDo]
    * http://en.cppreference.com/w/cpp/error/exception_ptr 
  * to_string(std::exception_ptr eptr) 구현은 
    node_util/string_conversion.hpp 참조  

* node_util::console::log 구현 관련 [ToDo]
