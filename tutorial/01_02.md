## 01_02.cpp
#### Rx 컨셉 및 규칙 
----------------

* 추가 내용 없음
  
#### Rx 내부 구현
----------------
* hander_next 함수에 braek_point를 잡고 소스 분석.
  * (브레이크 포인트 잡을 곳)
  ```cpp
  29:  auto handler_next = [](evt_t i) { console::log  ("on_next: "s  + i); };
  ```
  * [기본] 타이머 호출 후 부터 handelr_next 함수 호출까지의 코드 살펴보기 
  * [심화] hander_next 를 소유하고 있는 실제 rx 객체 타입 살펴 보기
    * rxcpp 에서는 
    ```cpp
      rxcpp::observer<
         int,  // 이벤트 타입
         rxcpp::detail::stateless_observer_tag, // 상태 없는 람다함수를 뜻하는 테그
         void <lambda>(int),  // on_next 타입
         <lambda_52b45dc0fe250fd7ec37ac13f954e1eb>, // on_error 타입
         void <lambda>(void) // on_complete 타입
       > 
    ```
    * rxjs 에서는  AnonymousObserver 클래스
  * [심화] detacher 객체 타입 및 기능 살펴보기
    * rxcpp 에서는 nextdetacher 클래스
    * rxjs 에서는 AutoDetachObserver 클래스

#### (Modern) C++
* [기본] 함수를 자료구조에 저장하기 (Function as first-class)
  * 계산(Computation, algorithm)을 자료구조에 저장하는 예
  ```cpp
  15:    std::array<std::function<void()>, 3> events = { 
  16:      [=] { observer.on_next(evt_t(21)); } 
  17:    , [=] { observer.on_completed();     } 
  18:    , [=] { observer.on_next(evt_t(22)); }
  19:  };
  ```
  * 자료구조에 저장된 계산을 다른 함수에 넘겨주는 예
  ```cpp
  21:  set_timeout(events[0], 1000ms);
  22:  set_timeout(events[1], 3000ms);
  23:  set_timeout(events[2], 5000ms);
  ```
